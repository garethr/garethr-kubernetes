
# This file is automatically generated by puppet-swagger-generator and
# any manual changes are likely to be clobbered when the files
# are regenerated.

require_relative '../../../puppet_x/puppetlabs/kubernetes/provider'

Puppet::Type.type(:kubernetes_persistent_volume_spec).provide(:swagger, :parent => PuppetX::Puppetlabs::Kubernetes::Provider) do

  mk_resource_methods

  def self.instance_to_hash(instance)
    {
    ensure: :present,
    name: instance.metadata.name,
    
      
        
        capacity: instance.capacity.respond_to?(:to_hash) ? instance.capacity.to_hash : instance.capacity,
        
      
    
      
        
        gce_persistent_disk: instance.gcePersistentDisk.respond_to?(:to_hash) ? instance.gcePersistentDisk.to_hash : instance.gcePersistentDisk,
        
      
    
      
        
        aws_elastic_block_store: instance.awsElasticBlockStore.respond_to?(:to_hash) ? instance.awsElasticBlockStore.to_hash : instance.awsElasticBlockStore,
        
      
    
      
        
        host_path: instance.hostPath.respond_to?(:to_hash) ? instance.hostPath.to_hash : instance.hostPath,
        
      
    
      
        
        glusterfs: instance.glusterfs.respond_to?(:to_hash) ? instance.glusterfs.to_hash : instance.glusterfs,
        
      
    
      
        
        nfs: instance.nfs.respond_to?(:to_hash) ? instance.nfs.to_hash : instance.nfs,
        
      
    
      
        
        rbd: instance.rbd.respond_to?(:to_hash) ? instance.rbd.to_hash : instance.rbd,
        
      
    
      
        
        iscsi: instance.iscsi.respond_to?(:to_hash) ? instance.iscsi.to_hash : instance.iscsi,
        
      
    
      
        
        cinder: instance.cinder.respond_to?(:to_hash) ? instance.cinder.to_hash : instance.cinder,
        
      
    
      
        
        cephfs: instance.cephfs.respond_to?(:to_hash) ? instance.cephfs.to_hash : instance.cephfs,
        
      
    
      
        
        fc: instance.fc.respond_to?(:to_hash) ? instance.fc.to_hash : instance.fc,
        
      
    
      
        
        flocker: instance.flocker.respond_to?(:to_hash) ? instance.flocker.to_hash : instance.flocker,
        
      
    
      
        
        flex_volume: instance.flexVolume.respond_to?(:to_hash) ? instance.flexVolume.to_hash : instance.flexVolume,
        
      
    
      
        
        azure_file: instance.azureFile.respond_to?(:to_hash) ? instance.azureFile.to_hash : instance.azureFile,
        
      
    
      
        
        vsphere_volume: instance.vsphereVolume.respond_to?(:to_hash) ? instance.vsphereVolume.to_hash : instance.vsphereVolume,
        
      
    
      
        
        quobyte: instance.quobyte.respond_to?(:to_hash) ? instance.quobyte.to_hash : instance.quobyte,
        
      
    
      
        
        azure_disk: instance.azureDisk.respond_to?(:to_hash) ? instance.azureDisk.to_hash : instance.azureDisk,
        
      
    
      
        
        photon_persistent_disk: instance.photonPersistentDisk.respond_to?(:to_hash) ? instance.photonPersistentDisk.to_hash : instance.photonPersistentDisk,
        
      
    
      
        
        portworx_volume: instance.portworxVolume.respond_to?(:to_hash) ? instance.portworxVolume.to_hash : instance.portworxVolume,
        
      
    
      
        
        scale_io: instance.scaleIO.respond_to?(:to_hash) ? instance.scaleIO.to_hash : instance.scaleIO,
        
      
    
      
        
        local: instance.local.respond_to?(:to_hash) ? instance.local.to_hash : instance.local,
        
      
    
      
        
        storageos: instance.storageos.respond_to?(:to_hash) ? instance.storageos.to_hash : instance.storageos,
        
      
    
      
        
        access_modes: hash_arrays(instance.accessModes),
        
      
    
      
        
        claim_ref: instance.claimRef.respond_to?(:to_hash) ? instance.claimRef.to_hash : instance.claimRef,
        
      
    
      
        
        persistent_volume_reclaim_policy: instance.persistentVolumeReclaimPolicy.respond_to?(:to_hash) ? instance.persistentVolumeReclaimPolicy.to_hash : instance.persistentVolumeReclaimPolicy,
        
      
    
      
        
        storage_class_name: instance.storageClassName.respond_to?(:to_hash) ? instance.storageClassName.to_hash : instance.storageClassName,
        
      
    
      
        
        mount_options: hash_arrays(instance.mountOptions),
        
      
    
    object: instance,
    }
  end

  def create
    Puppet.info("Creating kubernetes_persistent_volume_spec #{name}")
    create_instance_of('persistent_volume_spec', name, build_params)
  end

  def flush
   unless @property_hash.empty?
     unless resource[:ensure] == :absent
        flush_instance_of('persistent_volume_spec', name, @property_hash[:object], build_params)
      end
    end
  end

  def destroy
    Puppet.info("Deleting kubernetes_persistent_volume_spec #{name}")
    destroy_instance_of('persistent_volume_spec', name)
    @property_hash[:ensure] = :absent
  end

  private
  def self.list_instances
    list_instances_of('persistent_volume_spec')
  end

  def build_params
    params = {
    
      
        capacity: resource[:capacity],
      
    
      
        gcePersistentDisk: resource[:gce_persistent_disk],
      
    
      
        awsElasticBlockStore: resource[:aws_elastic_block_store],
      
    
      
        hostPath: resource[:host_path],
      
    
      
        glusterfs: resource[:glusterfs],
      
    
      
        nfs: resource[:nfs],
      
    
      
        rbd: resource[:rbd],
      
    
      
        iscsi: resource[:iscsi],
      
    
      
        cinder: resource[:cinder],
      
    
      
        cephfs: resource[:cephfs],
      
    
      
        fc: resource[:fc],
      
    
      
        flocker: resource[:flocker],
      
    
      
        flexVolume: resource[:flex_volume],
      
    
      
        azureFile: resource[:azure_file],
      
    
      
        vsphereVolume: resource[:vsphere_volume],
      
    
      
        quobyte: resource[:quobyte],
      
    
      
        azureDisk: resource[:azure_disk],
      
    
      
        photonPersistentDisk: resource[:photon_persistent_disk],
      
    
      
        portworxVolume: resource[:portworx_volume],
      
    
      
        scaleIO: resource[:scale_io],
      
    
      
        local: resource[:local],
      
    
      
        storageos: resource[:storageos],
      
    
      
        accessModes: resource[:access_modes],
      
    
      
        claimRef: resource[:claim_ref],
      
    
      
        persistentVolumeReclaimPolicy: resource[:persistent_volume_reclaim_policy],
      
    
      
        storageClassName: resource[:storage_class_name],
      
    
      
        mountOptions: resource[:mount_options],
      
    
    }
    params.delete_if { |key, value| value.nil? }
    params
  end
end
